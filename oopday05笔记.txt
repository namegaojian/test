复习
1.向上造型
1)什么是向上造型
  子类对象赋给父类引用
2)为什么需要向上造型
  减少代码冗余
3)语法
  <父类类型> <引用>=<子类对象>
4)问题
  父类的引用
  在编译期能够调用的
  只有父类的属性和方法

2.方法重写
1)什么是方法重写
2)为什么需要方法重写
3)怎么样实现方法重写
4)方法重写的效果
  父类引用
  调用方法,在运行时
  会运行子类重写后的方法

3.package
1)包的作用
  避免类名冲突
2)类名
  java中的全类名是唯一标识一个
  项目中的名称
  全类名:包名+类名
4.import关键字
1)导入其他包中的类
  在当前类使用
  避免使用了全类名
2)同一个类中不能导入两个同名类
  一个类中不能导入和自己类名相同的类
3)用法
  import <包名>.<类名>;
  import <包名>.*;
4)java默认导入的包
  java.lang.*;

5.访问修饰符
1)什么是访问修饰符
2)访问修饰符类型
  public
  protected
  默认
  private

6.final
1)修饰类
  表示这个类不能被继承
2)修饰方法
  表示这个方法不允许被子类重写
3)修饰成员变量(属性)
  属性值不能被修改
  赋值时
  1要么声明时赋值
  2要么构造方法中赋值
4)修饰局部变量
  修饰方法中声明的变量
      只能被赋值一次
  修饰方法的形式参数
      不能修改

笔记
1.static关键字
  static只能修饰成员,英文含义是静态
1)修饰属性
  1.1)被static修饰的属性
      所有对象共享同一个值
  1.2)被static修饰的属性值
      会被保存在内存的方法区中
  1.3)当该类的所有对象共享同一个
      资源时,将这个资源设置为静态
      能够节省内存
  1.4)官方建议静态属性使用类名调用
  1.5)静态属性也成为类属性

2)修饰方法
  2.1)使用static修饰方法
      该方法称之为静态方法,类方法
  2.2)静态方法可以直接使用类名调用
      无需实例化对象
  2.3)静态方法中无法调用
      普通(实例)属性和方法
      因为静态方法中没有this
  2.4)如果一个方法不需要
      访问当前类中的实例成员
      就可以定义成静态的
  2.5)静态方法不能被重写

3)修饰初始化块
  3.1)什么是初始化块
      在代码中直接编写{}
      {}中的内容就是初始化块
      初始化块中的内容
      会在构造方法运行前运行
  3.2)被static修饰的初始化块
      只会运行一次
  3.3)运行时机是JVM使用这个类之前
      JVM加载类时运行静态块
      加载类的情况
      1.实例化对象
      2.使用类名调用静态成员
      3.反射相关技术(二阶段讲)

2.java中的常量
1)什么是常量
  常量就是不会变化的数值
2)为什么需要常量
  方便程序员使用\调用不会变化的数值
3)常量的特性
  1不能修改
  2所有对象共享
4)常量一定是成员
5)定义一个常量
  public static final 
            <类型> <常量名>=<数值>;
  public static final double
             PI=3.1415926;
6)常量使用类名调用,不能修改
7)常量的命名规范
  所有字母均大写
  多个单词用_分割
8)常量的赋值有2种方式
  推荐:声明的同时赋值
       语法也允许在静态块中赋值
9)如果常量在声明的同时赋值
  代码中调用这个常量的位置
  编译时会替换成这个常量的值
  无需加载这个类,从而提高运行效率

3.抽象类
1)什么是抽象类
  不存在对象的类型,就是抽象类
2)抽象类的特征
  2.1)抽象类不能实例化
  2.2)抽象类中能编写抽象方法
  2.3)抽象类中的抽象方法数量不限
                          (0~无数)
3)如何编写抽象类
  使用abstract(抽象)修饰类即可

4.抽象方法
1)什么是抽象方法
  不能编写具体实现的方法
2)抽象方法的特征
  2.1)抽象方法不能写方法体
  2.2)抽象方法必须在子类中被重写
      除非子类也是抽象类
  2.2)抽象方法必须在抽象类中
3)怎么定义抽象方法
  在方法的返回值类型前
  编写abstract
  编写后这个方法的参数列表后
  只能跟";"

5.抽象类的好处
1)抽象类不能实例化
  只能作为父类,提供一个数据结构
  简化编程
2)子类中必须重写父类的抽象方法
  约束了子类行为,更加自然的使用
  向上造型和方法重写

PS:
  final关键字和abstract关键字矛盾
  不能同时修饰一个类或方法




作业
1)创建一个抽象的父类水果(Fruit)
  水果类中编写一个抽象方法eat()
  创建Apple类和Banana类继承水果
  重写eat方法
  测试类中定义一个水果数组
  向水果数组中赋值
  遍历数组元素调用eat方法


飞机大战
第一天
1.创建六个飞机大战中需要的类
  为他们设置基本的属性
  编写输出信息的方法
  创建一个带有main方法的类World
  实例化对象赋值,并调用方法

第二天
1.对每个类编写构造方法
  无参构造和全参构造
2.在world类中定义
  每个类型的变量或数组
  对他们赋值并测试

第三天
1.编写飞机大战的父类
  FlyingObject
2.编写2个FlyingObject类的构造
  一个用于小敌机,大敌机,奖励机
  另一个用于天空子弹英雄机
3.依次编写六个子类的
  构造方法
  调用父类的构造,实现对象属性的
                         初始化
第四天
1.所有子类重写父类中的show方法
2.World类中:
  将小敌机大敌机奖励机的数组
  合并为一个父类类型数组
  对父类数组赋值
  并遍历输出
3.使用访问修饰符修饰
  父类和子类中的属性

第五天
1.在FlyingObject类中
  定义一个读取图片的方法
2.在六个子类中
  分别设置静态的图片属性
  在静态块中对这些图片赋值
3.在World类中定义宽和高的常量

4.设置FlyingObject类为抽象类
  定义一个抽象方法step()
  六个子类分别重写step()





草稿

Dog[] dogs=new Dog[4];
Cat[] cats=new Cat[4];

Pet[] pets=new Pet[200];




Class 人{

   public void 写字(笔 a){
   
   }
   
}


Dog d=new Dog();
d.dogInfo();

Dog.dogInfo()

public void dogInfo(){
  syso("名字:"+this.name);

}


public static final
    int  DAY_HOUR=24;







